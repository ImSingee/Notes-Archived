- #CruelFundamental [[2022-01-24]]  [讨论](https://github.com/Monsooooon/CruelFundamental/tree/main/homework/202201/24)
-
- SQL 标准的[[事务]]隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）
-
- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
-
- **实例**
  collapsed:: true
	- ![2022_01_24_image.png](https://cdn.logseq.com/%2Fa738fab4-25bd-41b0-bb53-62a3b83356f256d0c0bf-e879-406d-aaa3-afc96619132f2022_01_24_image.png?Expires=4796634751&Signature=DLRNB8YNNO4QIbAuPZR0~1PobuBnrH8uOZRhOiJ7Tc1VuPuBF34HiUMYtGHTI4L5TF42JUbBHG0YkPIDnevXQ1gG8aMCipOHCAXOBhD7SFPwKnIenoMZyCf8NARCuOFqgF77whbUruMnM6i7giH4e4b49132tM4nFZs6JWdd8ljR8Gsii5oYCoslSiYa4jge6GEiAw6c2-0oxNsQXraJu8n4Fe9OwWvPhfwZDotXWR08znyqTRFxuMhjB0bzXcFAhB8uovCXm85ZJ4tGTMDOuygWsJ0Q5wADy~0iK789Zup7sWPrQnsdWAH9WNcTKMLwKkXi3Huf~UmXC-~nhou-xA__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA){:width 300}
	- 在读未提交的情况下，所有的改动实时展现
		- V1=2, V2=2, V3=2
	- 在读提交的情况下，其他的事务改动只有在那个事务提交时才会展现
		- V1=1, V2=2, V3=2
	- 在可重复读的情况下，认为启动事务时「打了一个快照」，其他的事务影响仅会在当前事务提交后展现
		- V1=1, V2=1, V3=2
	- 在串行化的情况下，会涉及到读写锁，锁在相关记录被读写时获取、整个事务提交时才释放
		- A 查询时上读锁
		- B 查询时也上读锁（成功）
		- B 修改时上写锁，但因为 A 已经持有了读锁，因此会在这一步等待
		- A 查询得到值 V1=1
		- A查询得到值 V2=1
		- A 提交事务，读锁被释放
		- 这时上面第 3 步的 B 上写锁成功，将值改为 2
		- B 提交事务，写锁被释放
		- 事务 A 结束后查询的 V3=2（是否存在可能 V3=1？）
-
- 站在[[视图]]的角度去看隔离级别
	- RU 读未提交：不使用视图，始终使用行的当前值
	- RC 读提交：视图在每个 SQL 语句执行时创建，事务提交时提交
	- RR 可重复读：视图在事务开始时创建、事务提交时提交
	- Serial 串行化：利用读写锁，不使用视图